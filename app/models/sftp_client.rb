require 'net/sftp'

# PLEASE NOTE: There is a monkey patch in application.rb that extends
# the fun_sftp gem.

# SFTP Client object used by the SftpService class
class SftpClient
  include ActiveModel::Model
  include FunSftp
  attr_accessor :host, :port, :username, :password, :directory

  # on instantiation, init credentials, and connect
  def initialize(attributes = {})
    super(attributes)
    init_credentials
    connect
  end

  def chdir(directory)
    # TODO: Throw a bigger fit if we can't change to the passed-in directory.
    # Otheriwse, the subsequent file upload will end up in the last directory
    # it was able to change to. Maybe that's OK. Maybe not.
    return if directory.blank?
    @sftp.chdir(directory)
  end

  # upload a text string directly to a remote location as file_name
  def upload_string(string, file_name)
    raise 'File name required' if file_name.blank?
    success = false
    retry_count = 3
    until success
      begin
        @sftp.upload!(StringIO.new(string), file_name)
        raise StandardError unless file_exists?(file_name)
        success = true
      rescue StandardError => e
        retry_count -= 1
        raise "SFTP file error: #{e}" if retry_count == 0
        Delayed::Worker.logger.debug("Unable to upload file to #{@host}. " \
          "Reason: #{e}")
        Delayed::Worker.logger.debug("Retrying file upload to #{@host}.")
      end
    end
  end

  def close
    @sftp.close unless @sftp.blank?
  rescue StandardError => e
    Delayed::Worker.logger.debug('Unable to close ftp connection to ' \
      "#{@host}:#{@port} #{e}")
  end

  # Can the client write to current directory?
  def can_write_files?
    file_name = test_file_name
    upload_string('Test file generated by automated ' \
      'FTP delivery. Please discard.', file_name)
    return false unless file_exists?(file_name)
    begin
      @sftp.rm(file_name)
    rescue StandardError => e
      Delayed::Worker.logger.debug("Unable to delete test file. Reason: #{e}")
    end
    true
  end

  private

  def connect
    success = false
    retry_count = 3
    until success
      begin
        # The fun_sftp gem isn't smart enough to know what to do with the value
        # of the password parameter when a port is also passed in. See for
        # yourself in the setup_login method in fun_sftp.rb in the gem. This
        # means we need to pass it in twice.
        # also, don't do a fully qualified folder location, because the
        # app lives in 'asq' in dev, but 'sql-monitor' in prod.
        @sftp = SFTPClient.new(
          @host, @username, @password,
          password: @password, port: @port, number_of_password_prompts: 0,
          keys: ['config/keys/id_rsa'], timeout: 120
        )
        success = true
      rescue StandardError => e
        retry_count -= 1
        raise "SFTP connection error: #{e}" if retry_count == 0
        Delayed::Worker.logger.debug("Unable to connect to #{@host}. " \
          "Reason: #{e}")
        Delayed::Worker.logger.debug("Retrying connection to #{@host}.")
      end
    end
  end

  # sets default credential options
  def init_credentials
    raise 'hostname required' if @host.blank?
    @port = '22' if @port.blank?
    # remvove protocol prefix from hostname (eg, ftp://myftp becomes myftp)
    @host.gsub!(%r{.+://}, '')
  end

  # generates random string for file name
  def random_file_name
    SecureRandom.hex[0, 8] + '.txt'
  end

  # checks if file exists in curren directory
  def file_exists?(file_name)
    begin
      @sftp.size(file_name)
    rescue StandardError
      return false
    end
    true
  end

  # gets unique filename for current directory
  def test_file_name
    file_name = nil
    i = 0
    # generate a random file name that doesn't exists on server
    while file_name.blank?
      temp_fn = random_file_name
      file_name = temp_fn unless file_exists?(temp_fn)
      i += 1
      raise 'too many random file name retries' if i > 10
    end
    file_name
  end
end
